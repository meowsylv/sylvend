const fs = require("fs");
const path = require("path");
const separator = "---";
const package = require("./package.json");
const express = require("express");
const Logger = require("./logging");
const logger = new Logger("templates");

function getPage(content, template, peopleManager, configManager, req, debug = false) {
    if(process.argv.includes("--debug")) debug = true;
    try {
        let page = template.getTemplate();
        page = `<!-- This page was autogenerated by ${package.name} v${package.version} on ${new Date().toString()} -->\n` + page;
        let separatorIndex = content.indexOf(separator);
        let head = separatorIndex === -1 ? "" : content.slice(0, separatorIndex).trim();
        let body = separatorIndex === -1 ? content : content.slice(separatorIndex + separator.length).trim();
        page = page.replace(/\{head\}/, head).replace(/\{body\}/, body);
        let lastSearchIndex;
        let searchIndex = 0;
        let startIndex = -1;
        let level = 0;
        let methods = template.initMethods({ package, req, peopleManager, configManager });
        while((startIndex = page.indexOf("!{", searchIndex)) !== -1) {
            level = 1;
            let ignore = false;
            searchIndex = startIndex + 1;
            if(page.charAt(startIndex - 1) === "\\" && page.charAt(startIndex - 2) !== "\\") {
                page = page.slice(0, startIndex - 1) + page.slice(startIndex);
                continue;
            }
            while(level > 0) {
                searchIndex = page.slice(searchIndex + 1).search(/\"|\"|\{|\}/) + searchIndex + 1;
                if(searchIndex === -1 || searchIndex === lastSearchIndex) {
                    throw new Error(`} expected. Parsing stopped.`);
                }
                if(page.charAt(searchIndex) === "\"") {
                    ignore = !ignore;
                }
                if(!ignore) {
                    switch(page.charAt(searchIndex)) {
                        case "{" :
                            level++;
                        break;
                        case "}" :
                            level--;
                        break
                    }
                }
                lastSearchIndex = searchIndex;
            }
            let methodContents = page.slice(startIndex + 2, searchIndex);
            let colonIndex = methodContents.indexOf(":");
            if(colonIndex === -1) colonIndex = searchIndex;
            let methodName = methodContents.slice(0, colonIndex);
            let params = JSON.parse(methodContents.slice(colonIndex + 1) || null);
            let methodLength = searchIndex + 1 - startIndex;
            function methodReplace(page, contents) {
                return page.slice(0, startIndex) + contents + page.slice(startIndex + methodLength);
            }
            try {
                page = methods[methodName]({ params, page, start: startIndex, length: methodLength, replace: methodReplace });
            }
            catch(err) {
                page = methodReplace(page, debug ? log(`Failed to run method '${methodName}'.<br><pre><code>${err.stack}</code></pre>`, "error") : "");
            }
            lastSearchIndex = -1;
            searchIndex = startIndex;
        }
        return page;
    }
    catch(err) {
        console.error("Page generation error.");
        console.error(err);
        throw new Error("Page generation error. Please check logs.");
    }
}

/*function loadTemplateDir(dir) {
    let template = fs.readFileSync(path.join(dir, "template.html"));
    let methods = require(path.join(dir, "methods.js"));
    let { name, description }= require(path.join(dir, "info.json"));
    return new Template(template, methods, name, description);
}*/

function parseAndSave(template, dir, outputDir, managementPath, peopleManager, configManager, options = {}) {
    let files = fs.readdirSync(dir);
    let managementDir = false;
    for(let file of files) {
        let filePath = path.join(dir, file);
        let outputPath = path.join(outputDir, file);
        
        if(fs.statSync(filePath).isDirectory()) {
            if(file === "management" && !options.managementIgnore) {
                logger.log(`Management folder detected. Moving to management directory...`);
                outputPath = managementPath;
                managementDir = true;
            }
            try {
                fs.accessSync(outputPath);
            }
            catch {
                fs.mkdirSync(outputPath);
                logger.log(`${filePath} -> ${outputPath} (new directory)`);
            }
            parseAndSave(template, filePath, outputPath, managementPath, peopleManager, configManager, { managementIgnore: true });
        }
        else {
            fs.writeFileSync(outputPath, getPage(fs.readFileSync(filePath).toString(), template, peopleManager, configManager));
            logger.log(`${filePath} -> ${outputPath}`);
        }
    }
    if(!managementDir && !options.managementIgnore) logger.log("WARNING: THERE'S NO MANAGEMENT DIRECTORY! management will either load the current management files or load the fallback one.");
}

function log(message, severity = "INFO") {
    return `<b>${package.name} [${severity.toUpperCase()}]:</b> ${message}<br>`;
}

class Template {
    constructor(dir) {
        this.dir = dir;
    }
    getInfo() {
        return require(path.join(this.dir, "info.json"));
    }
    initMethods(options) {
        return require(path.join(this.dir, "methods"))(options);
    }
    getTemplate() {
        return fs.readFileSync(path.join(this.dir, "template.html")).toString();
    }
}    

class TemplateManager {
    constructor(peopleManager, configManager, errorManager, template) {
        if(template) this.setTemplate(template);
        this.peopleManager = peopleManager;
        this.configManager = configManager;
        this.errorManager = errorManager;
    }
    
    setTemplate(template) {
        this.template = template;
    }
    
    serve(htmlPath) {
        return (req, res, next) => {
            if(!this.template) {
                next();
                return;
            }
            let content;
            let contentPath = path.join(htmlPath, req.url);
            try {
                fs.accessSync(contentPath);
            }
            catch {
                next();
                return;
            }
            let stats = fs.statSync(contentPath);
            if(stats.isDirectory()) {
                if(req.originalUrl.endsWith("/")) {
                    contentPath += "index.html";
                }
                else {
                    res.status(301).location(req.originalUrl + "/").send(this.errorManager.getErrorPage(301, this.peopleManager, `This is a directory, so it has to have a slash at the end of the path. We're gonna redirect you to the correct path.`));
                    return;
                }
            }
            content = fs.readFileSync(contentPath).toString();
            res.type("text/html").send(getPage(content, this.template, this.peopleManager, this.configManager, req));
            
        }
    }
}

module.exports = { parseAndSave, getPage, Template, TemplateManager };
logger.ready();
